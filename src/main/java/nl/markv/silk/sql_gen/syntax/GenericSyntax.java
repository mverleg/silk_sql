package nl.markv.silk.sql_gen.syntax;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import nl.markv.silk.sql_gen.sqlparts.ListEntry;
import nl.markv.silk.sql_gen.sqlparts.Statement;
import nl.markv.silk.types.Column;
import nl.markv.silk.types.DataType;
import nl.markv.silk.types.DatabaseSpecific;
import nl.markv.silk.types.ForeignKey;
import nl.markv.silk.types.Row;
import nl.markv.silk.types.Table;
import nl.markv.silk.types.UniqueConstraint;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static nl.markv.silk.sql_gen.sqlparts.ListEntry.listEntry;
import static nl.markv.silk.sql_gen.sqlparts.Statement.comment;
import static nl.markv.silk.sql_gen.sqlparts.Statement.statement;
import static nl.markv.silk.sql_gen.sqlparts.StringEmptyLine.emptyLine;
import static org.apache.commons.lang3.Validate.isTrue;
import static org.apache.commons.lang3.Validate.notNull;

/**
 * Attempt at a common version of SQL syntax.
 *
 * Dialect implementations can extend this and override their dialect's peculiarities.
 */
public abstract class GenericSyntax implements Syntax {

	protected final boolean quoteNames;
	protected final boolean terse;
	protected String schemaName;
	protected String silkVersion;

	public GenericSyntax(@Nonnull String schemaName, @Nonnull String silkVersion, @Nonnull Syntax.SyntaxOptions options) {
		this.schemaName = schemaName;
		this.silkVersion = silkVersion;
		this.quoteNames = options.quoteNames;
		this.terse = options.terse;
	}

	@Override
	@Nonnull
	public List<Statement> prelude(@Nullable DatabaseSpecific db) {
		return asList(
				comment("sql dialect: ", dialectName()),
				emptyLine(),
				comment("start schema ", schemaName),
				comment("generated by silk_sql_gen")
		);
	}

	@Nonnull
	protected abstract String dialectName();

	@Override
	@Nonnull
	public List<Statement> postlude(@Nullable DatabaseSpecific db) {
		return singletonList(comment("end schema ", schemaName));
	}

	@Override
	@Nonnull
	public String startTable(@Nonnull Table table) {
		return "create table " + quoted(table.name) + " (";
	}

	@Override
	@Nonnull
	public String endTable(@Nonnull Table table) {
		return ")";
	}

	@Nonnull
	@Override
	public TableEntrySyntax<ColumnInfo, ListEntry> columnInCreateTableSyntax() {
		return (table, info) -> {
			StringBuilder sql = new StringBuilder();
			Column column = info.column;
			sql.append(quoted(column.name));
			sql.append(" ");
			sql.append(info.dataTypeName);
			if (info.primaryKey == MetaInfo.PrimaryKey.Single) {
				sql.append(" primary key");
			} else if (info.autoValueName != null) {
				isTrue(column.defaultValue == null);
				sql.append(" ");
				sql.append(info.autoValueName);
			} else if (column.defaultValue != null) {
				sql.append(" default ");
				sql.append(valueToSql(column.type, column.defaultValue));
			} else if (!column.nullable) {
				sql.append(" not null");
			}
			return singletonList(listEntry(sql.toString()));
		};
	}

	@Nonnull
	protected String valueToSql(@Nonnull DataType type, @Nullable Object value) {
		if (value == null) {
			return "null";
		}
		if (type instanceof DataType.Text) {
			String escaped = value.toString().replace("\\", "\\\\").replace("\"", "\\\"");
			return "\"" + escaped + "\"";
		}
		if (type instanceof DataType.Int) {
			return value.toString();
		}
		if (type instanceof DataType.Decimal) {
			//TODO @mark: make sure number of decimals here is correct
			return value.toString();
		}
		if (type instanceof DataType.Timestamp) {
			// Use 'notNull' because valueToJson should only return null for null inputs,
			// which cannot happen here.
			return notNull(type.valueToJson(value)).toString();
		}
		throw new IllegalArgumentException("Got value '" + value + "' of type " + type +
				", which is not currently supported");
	}

	@Nonnull
	@Override
	public Optional<TableEntrySyntax<List<Column>, ListEntry>> primaryKeyInCreateTableSyntax() {
		return Optional.of((table, pk) -> {
			if (pk.size() > 1) {
				return singletonList(listEntry(
						"primary key(",
						pk.stream().map(c -> quoted(c.name)).collect(Collectors.joining(", ")),
						")"
				));
			} else {
				return emptyList();
			}
		});
	}

	@Nonnull
	@Override
	public Optional<TableEntrySyntax<List<Column>, Statement>> addPrimaryKeyToExistingTableSyntax() {
		// Primary key is specified inline by default.
		//TODO: perhaps this will need to change when composite primary keys are supported
		return Optional.empty();
	}

	@Nonnull
	@Override
	public Optional<TableEntrySyntax<UniqueConstraint, Statement>> addUniqueToExistingTableSyntax() {
		// Unicity is added when creating table by default,
		// but this hook is used to add an index on unique columns that don't have one.
		return Optional.of((table, unique) -> singletonList(statement(
				"create unique index if not exists ",
				quoted(nameFromCols("i", unique.table.name, unique.columnsNames)),
				" on ",
				quoted(table.name),
				" (",
				unique.columnsNames.stream().map(n -> quoted(n)).collect(Collectors.joining(", ")),
				")"
		)));
	}

	@Nonnull
	@Override
	public Optional<TableEntrySyntax<ForeignKey, Statement>> addReferenceToExistingTableSyntax() {
		// Foreign keys are added when creating table by default,
		// but this hook is used to add an index on columns that are references by a foreign key.
		// This happens after unique constraint indices, so if both apply, the unique index prevails.
		return Optional.of((table, fk) -> singletonList(statement(
				"create index if not exists ",
				quoted(nameFromCols("i", fk.targetTableName, fk.targetColumns(c -> c.name))),
				" on ",
				quoted(table.name),
				" (",
				String.join(", ", fk.targetColumns(c1 -> quoted(c1.name))),
				")"
		)));
	}

	public class GenericInsertSyntax implements Syntax.InsertSyntax {

		@Override
		public int rowsPerStatement() {
			return 100;
		}

		@Nonnull
		@Override
		public String insertBegin(@Nonnull Table table) {
			StringBuilder sql = new StringBuilder();
			if (!terse && table.data.nonDataColumns().findAny().isPresent()) {
				sql.append("-- columns filled from default values: ");
				sql.append(table.data.nonDataColumns()
						.map(col -> col.name)
						.collect(Collectors.joining(", ")));
				sql.append(".\n");
			}
			sql.append("insert into ");
			sql.append(quoted(table.name));
			sql.append(" (\n");
			sql.append(table.data.dataColumns()
					.map(col -> quoted(col.name))
					.collect(Collectors.joining(terse ? "," : ",\n")));
			sql.append("\n) values\n");
			return sql.toString();
		}

		@Nonnull
		@Override
		public String dataRowInsert(@Nonnull Table table, @Nonnull Row row, boolean isFirst) {
			StringBuilder sql = new StringBuilder();
			if (!isFirst) {
				sql.append(",");
			}
			sql.append(" (\n");
			sql.append(row.cells()
					//TODO @mark: what is the formatting here?
					.map(val -> val.toString())
					.collect(Collectors.joining(terse ? "," : ",\n")));
			sql.append("\n)");
			return sql.toString();
		}

		@Nonnull
		@Override
		public String insertEnd(@Nonnull Table table) {
			return "";
		}
	}

	@Nonnull
	@Override
	public Optional<InsertSyntax> insert() {
		return Optional.of(new GenericInsertSyntax());
	}

	@Nonnull
	protected static String nameFromCols(@Nullable String prefix, @Nonnull String table, @Nonnull List<String> columns) {
		StringBuilder sql = new StringBuilder();
		if (prefix != null) {
			sql.append(prefix);
			sql.append("_");
		}
		sql.append(table);
		sql.append("_");
		boolean isFirst = true;
		for (String col : columns) {
			if (isFirst) {
				isFirst = false;
			} else {
				sql.append("_");
			}
			sql.append(col);
		}
		return sql.toString();
	}

	@Nonnull
	protected static String nameFromHash(@Nonnull String prefix, @Nonnull String hashInput) {
		MessageDigest digest;
		try {
			digest = MessageDigest.getInstance("SHA-256");
		} catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException(ex);
		}
		byte[] bytes = digest.digest(hashInput.getBytes(StandardCharsets.UTF_8));
		String hash = new String(Base64.getEncoder().encode(bytes))
				.replace("+", "")
				.replace("/", "")
				.replace("=", "");
		return prefix + hash.substring(0, 16);
	}

	@Nonnull
	protected String quoted(@Nonnull String name) {
		if (quoteNames) {
			return "\"" + name + "\"";
		}
		return name;
	}
}
